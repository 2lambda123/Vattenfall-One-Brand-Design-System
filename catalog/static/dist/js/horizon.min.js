/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(1);
__webpack_require__(3);
__webpack_require__(4);
__webpack_require__(5);
__webpack_require__(6);
__webpack_require__(7);
__webpack_require__(8);

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

const Rellax = __webpack_require__(2);

// Only intiate parallax for larger screens
if (window.innerWidth >= 992) {
  if (document.getElementsByClassName('vf-two-column-boxes__image').length > 0) {
    var rellax1 = new Rellax('.vf-two-column-boxes__image', {
      speed: 1,
      center: true,
      wrapper: null,
      round: true,
      vertical: true,
      horizontal: false,
      callback: function (pos, element, percentages) {
        var y = percentages.y;
        var image = element.children[0];
        var size = 1 + y;
        image.style.transform = 'scale(' + size.toString() + ')';
      }
    });
  }

  if (document.getElementsByClassName('vf-two-column-boxes__headline').length > 0) {
      var rellax2 = new Rellax('.vf-two-column-boxes__headline', {
      speed: -1,
      center: true,
      wrapper: null,
      round: true,
      vertical: true,
      horizontal: false
    });
  }

  if (document.getElementsByClassName('vf-two-column-boxes__content').length > 0) {
    var rellax3 = new Rellax('.vf-two-column-boxes__content', {
      speed: -1,
      center: true,
      wrapper: null,
      round: true,
      vertical: true,
      horizontal: false
    });
  }
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
// ------------------------------------------
// Rellax.js
// Buttery smooth parallax library
// Copyright (c) 2016 Moe Amaya (@moeamaya)
// MIT license
//
// Thanks to Paraxify.js and Jaime Cabllero
// for parallax concepts
// ------------------------------------------

(function (root, factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof module === 'object' && module.exports) {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.Rellax = factory();
  }
}(this, function () {
  var Rellax = function(el, options){
    "use strict";

    var self = Object.create(Rellax.prototype);

    var posY = 0;
    var screenY = 0;
    var posX = 0;
    var screenX = 0;
    var blocks = [];
    var pause = true;

    // check what requestAnimationFrame to use, and if
    // it's not supported, use the onscroll event
    var loop = window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      function(callback){ return setTimeout(callback, 1000 / 60); };

    // store the id for later use
    var loopId = null;

    // check what cancelAnimation method to use
    var clearLoop = window.cancelAnimationFrame || window.mozCancelAnimationFrame || clearTimeout;

    // check which transform property to use
    var transformProp = window.transformProp || (function(){
        var testEl = document.createElement('div');
        if (testEl.style.transform === null) {
          var vendors = ['Webkit', 'Moz', 'ms'];
          for (var vendor in vendors) {
            if (testEl.style[ vendors[vendor] + 'Transform' ] !== undefined) {
              return vendors[vendor] + 'Transform';
            }
          }
        }
        return 'transform';
      })();

    // Default Settings
    self.options = {
      speed: -2,
      center: false,
      wrapper: null,
      relativeToWrapper: false,
      round: true,
      vertical: true,
      horizontal: false,
      callback: function() {},
    };

    // User defined options (might have more in the future)
    if (options){
      Object.keys(options).forEach(function(key){
        self.options[key] = options[key];
      });
    }

    // By default, rellax class
    if (!el) {
      el = '.rellax';
    }

    // check if el is a className or a node
    var elements = typeof el === 'string' ? document.querySelectorAll(el) : [el];

    // Now query selector
    if (elements.length > 0) {
      self.elems = elements;
    }

    // The elements don't exist
    else {
      throw new Error("The elements you're trying to select don't exist.");
    }

    // Has a wrapper and it exists
    if (self.options.wrapper) {
      if (!self.options.wrapper.nodeType) {
        var wrapper = document.querySelector(self.options.wrapper);

        if (wrapper) {
          self.options.wrapper = wrapper;
        } else {
          throw new Error("The wrapper you're trying to use don't exist.");
        }
      }
    }


    // Get and cache initial position of all elements
    var cacheBlocks = function() {
      for (var i = 0; i < self.elems.length; i++){
        var block = createBlock(self.elems[i]);
        blocks.push(block);
      }
    };


    // Let's kick this script off
    // Build array for cached element values
    var init = function() {
      for (var i = 0; i < blocks.length; i++){
        self.elems[i].style.cssText = blocks[i].style;
      }

      blocks = [];

      screenY = window.innerHeight;
      screenX = window.innerWidth;
      setPosition();

      cacheBlocks();

      // If paused, unpause and set listener for window resizing events
      if (pause) {
        window.addEventListener('resize', init);
        pause = false;
      }
      animate();
    };

    // We want to cache the parallax blocks'
    // values: base, top, height, speed
    // el: is dom object, return: el cache values
    var createBlock = function(el) {
      var dataPercentage = el.getAttribute( 'data-rellax-percentage' );
      var dataSpeed = el.getAttribute( 'data-rellax-speed' );
      var dataZindex = el.getAttribute( 'data-rellax-zindex' ) || 0;

      // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)
      // ensures elements are positioned based on HTML layout.
      //
      // If the element has the percentage attribute, the posY and posX needs to be
      // the current scroll position's value, so that the elements are still positioned based on HTML layout
      var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);
      // If the option relativeToWrapper is true, use the wrappers offset to top, subtracted from the current page scroll.
      if (self.options.relativeToWrapper) {
        var scrollPosY = (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);
        wrapperPosY = scrollPosY - self.options.wrapper.offsetTop;
      }
      var posY = self.options.vertical ? ( dataPercentage || self.options.center ? wrapperPosY : 0 ) : 0;
      var posX = self.options.horizontal ? ( dataPercentage || self.options.center ? (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft) : 0 ) : 0;

      var blockTop = posY + el.getBoundingClientRect().top;
      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;

      var blockLeft = posX + el.getBoundingClientRect().left;
      var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth;

      // apparently parallax equation everyone uses
      var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);
      var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);
      if(self.options.center){ percentageX = 0.5; percentageY = 0.5; }

      // Optional individual block speed as data attr, otherwise global speed
      var speed = dataSpeed ? dataSpeed : self.options.speed;

      var bases = updatePosition(percentageX, percentageY, speed);

      // ~~Store non-translate3d transforms~~
      // Store inline styles and extract transforms
      var style = el.style.cssText;
      var transform = '';

      // Check if there's an inline styled transform
      if (style.indexOf('transform') >= 0) {
        // Get the index of the transform
        var index = style.indexOf('transform');

        // Trim the style to the transform point and get the following semi-colon index
        var trimmedStyle = style.slice(index);
        var delimiter = trimmedStyle.indexOf(';');

        // Remove "transform" string and save the attribute
        if (delimiter) {
          transform = " " + trimmedStyle.slice(11, delimiter).replace(/\s/g,'');
        } else {
          transform = " " + trimmedStyle.slice(11).replace(/\s/g,'');
        }
      }

      return {
        baseX: bases.x,
        baseY: bases.y,
        top: blockTop,
        left: blockLeft,
        height: blockHeight,
        width: blockWidth,
        speed: speed,
        style: style,
        transform: transform,
        zindex: dataZindex
      };
    };

    // set scroll position (posY, posX)
    // side effect method is not ideal, but okay for now
    // returns true if the scroll changed, false if nothing happened
    var setPosition = function() {
      var oldY = posY;
      var oldX = posX;

      posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;
      posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset;
      // If option relativeToWrapper is true, use relative wrapper value instead.
      if (self.options.relativeToWrapper) {
        var scrollPosY = (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;
        posY = scrollPosY - self.options.wrapper.offsetTop;
      }


      if (oldY != posY && self.options.vertical) {
        // scroll changed, return true
        return true;
      }

      if (oldX != posX && self.options.horizontal) {
        // scroll changed, return true
        return true;
      }

      // scroll did not change
      return false;
    };

    // Ahh a pure function, gets new transform value
    // based on scrollPosition and speed
    // Allow for decimal pixel values
    var updatePosition = function(percentageX, percentageY, speed) {
      var result = {};
      var valueX = (speed * (100 * (1 - percentageX)));
      var valueY = (speed * (100 * (1 - percentageY)));

      result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;
      result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;

      return result;
    };

    // Loop
    var update = function() {
      if (setPosition() && pause === false) {
        animate();
      }

      // loop again
      loopId = loop(update);
    };

    // Transform3d on parallax element
    var animate = function() {
      var positions;
      for (var i = 0; i < self.elems.length; i++){
        var percentageY = ((posY - blocks[i].top + screenY) / (blocks[i].height + screenY));
        var percentageX = ((posX - blocks[i].left + screenX) / (blocks[i].width + screenX));

        // Subtracting initialize value, so element stays in same spot as HTML
        positions = updatePosition(percentageX, percentageY, blocks[i].speed);// - blocks[i].baseX;
        var positionY = positions.y - blocks[i].baseY;
        var positionX = positions.x - blocks[i].baseX;

        var zindex = blocks[i].zindex;

        // Move that element
        // (Set the new translation and append initial inline transforms.)
        var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;
        self.elems[i].style[transformProp] = translate;
        self.options.callback(positions, self.elems[i], {
          x: percentageX,
          y: percentageY
        });
      }
    };

    self.destroy = function() {
      for (var i = 0; i < self.elems.length; i++){
        self.elems[i].style.cssText = blocks[i].style;
      }

      // Remove resize event listener if not pause, and pause
      if (!pause) {
        window.removeEventListener('resize', init);
        pause = true;
      }

      // Clear the animation loop to prevent possible memory leak
      clearLoop(loopId);
      loopId = null;
    };

    // Init
    init();

    // Start the loop
    update();

    // Allow to recalculate the initial values whenever we want
    self.refresh = init;

    return self;
  };
  return Rellax;
}));

/***/ }),
/* 3 */
/***/ (function(module, exports) {

(function($) {
  var CheckboxDropdown = function(el) {
    var _this = this;
    this.isOpen = false;
    this.areAllChecked = false;
    this.$el = $(el);
    this.$label = this.$el.find(".vf-dropdown-label");
    this.$list = this.$el.find(".vf-dropdown-list .vf-dropdown-list-item");

    this.$inputs = this.$el.find('[type="checkbox"]');

    if (this.$inputs.length) {
      this.type = "checkbox";

      this.$inputs.on("change", function(e) {
        _this.onCheckBox();
      });
    } else {
      this.type = "click";

      $(this.$list).click(function(event) {
        $(this).siblings().removeClass("checked");
        $(this).addClass("checked");
        _this.onCheckBox();
        _this.toggleOpen(); //Close

      });
    }

    this.onCheckBox();

    this.$label.on("click", function(e) {
      e.preventDefault();
      _this.toggleOpen();
    });
  };

  CheckboxDropdown.prototype.onCheckBox = function() {
    this.updateStatus();
  };

  CheckboxDropdown.prototype.updateStatus = function() {
    var checked = "";

    if (this.type === "checkbox") {
      checked = this.$el.find(":checked");
    } else if (this.type === "click") {
      checked = this.$el.find(".checked");
    }

    var checkedArray = [];

    checked.each(function(i) {
      checkedArray.push($(this).attr("value"));
    });

    this.$el.attr("data-selected", checkedArray.join());

    this.areAllChecked = false;

    if (checked.length <= 0) {
      this.$label.html("Select option");
    } else if (checked.length === 1) {
      if (this.type === "checkbox") {
        this.selected = checked.next("label").text();
        this.$label.html(this.selected);
      } else if (this.type === "click") {
        this.selected = checked.find("label").text();
        this.$label.html(this.selected);
      }
    } else if (checked.length === this.$inputs.length) {
      this.$label.html("All Selected");
      this.areAllChecked = true;
    } else {
      this.$label.html(checked.length + " Selected");
    }
  };

  CheckboxDropdown.prototype.toggleOpen = function(forceOpen) {
    var _this = this;

    if (!this.isOpen || forceOpen) {
      this.isOpen = true;
      this.$el.addClass("on");
      $(document).on("click", function(e) {
        if (!$(e.target).closest("[data-control]").length) {
          _this.toggleOpen();
        }
      });
    } else {
      this.isOpen = false;
      this.$el.removeClass("on");
      $(document).off("click");
    }
  };

  var checkboxesDropdowns = document.querySelectorAll(
    '[data-control="vf-dropdown-data"]'
  );
  for (var i = 0, length = checkboxesDropdowns.length; i < length; i++) {
    new CheckboxDropdown(checkboxesDropdowns[i]);
  }
})(jQuery);


/***/ }),
/* 4 */
/***/ (function(module, exports) {

(function($){

	$('.vf-input').each(function( index ) {

		$(this).on('keyup',function(){

			if($(this).val().length === 0){

				if($(this).hasClass('vf-input--data')){
					$(this).removeClass('vf-input--data');
				}
			}
			else{
				//Prevent label from returning to original position.
				if(!$(this).hasClass('vf-input--data')){
					$(this).addClass('vf-input--data');
				}
			}
		});

		if($(this).attr('type') == 'number'){

			//stepUp() & stepDown() errors on IE11 - get Step value. Default 1.
			var stepValue = 1;
			if(this.getAttribute('step')){
				stepValue = this.getAttribute('step');
			}			
			
			if (!$(this).siblings().hasClass('vf-input--number-decrement')) {
				$('<div class="vf-input--number-decrement vf-icon-down"></div>').insertAfter(this);
			}

			if (!$(this).siblings().hasClass('vf-input--number-increment')) {
				$('<div class="vf-input--number-increment vf-icon-up"></div>').insertAfter(this);
			}

			$('.vf-input--number-increment, .vf-input--number-decrement').unbind().on('click keyup',function(){

				if(!$(this).closest('.vf-input-container').find('.vf-input').hasClass("vf-input--data")){

					//Move label
					$(this).closest('.vf-input-container').find('.vf-input').addClass("vf-input--data");

				}

				if($(this).hasClass("vf-input--number-increment")){

					if($.isNumeric(this.parentNode.querySelector('.vf-input').value)){
					
						this.parentNode.querySelector('.vf-input').value = Number(this.parentNode.querySelector('.vf-input').value) + Number(stepValue);
					}
					else{
						this.parentNode.querySelector('.vf-input').value = stepValue;
					}

				}

				else if($(this).hasClass("vf-input--number-decrement")){

					if($.isNumeric(this.parentNode.querySelector('.vf-input').value)){

						this.parentNode.querySelector('.vf-input').value = Number(this.parentNode.querySelector('.vf-input').value) - Number(stepValue);

					}
					else{
						this.parentNode.querySelector('.vf-input').value = -Math.abs(stepValue);
					}
				}

			});
		}

	});

})(jQuery);

/***/ }),
/* 5 */
/***/ (function(module, exports) {

(function($){

	$('.vf-tab-bar-item').each(function( index ) {

		if($(this).hasClass('vf-tab-bar-item--active')){

			$(this).find('.vf-tab-bar-link').clone().addClass('vf-tab-bar-link-mobile vf-tab-bar-link-mobile--active').removeClass('vf-tab-bar-link').removeAttr('aria-selected tabindex').insertAfter($(this));

		}

		else{

			$(this).find('.vf-tab-bar-link').clone().addClass('vf-tab-bar-link-mobile').removeClass('vf-tab-bar-link').removeAttr('aria-selected tabindex').insertAfter($(this));

		}

	});

	$('.vf-tab-bar-item').unbind().on('click keyup',function(){

		if(!$(this).hasClass('vf-tab-bar-item--disabled')){

			$(this).addClass('vf-tab-bar-item--active').attr({'aria-selected':'true', 'tabindex':'0'}).siblings().removeClass('vf-tab-bar-item--active').attr({'aria-selected':'false', 'tabindex':'-1'});

			$(this).nextAll('.vf-tab-bar-link-mobile:first').addClass('vf-tab-bar-link-mobile--active').siblings('.vf-tab-bar-link-mobile').removeClass('vf-tab-bar-link-mobile--active');

			$(this).closest('.vf-tab-bar-container').find('[role="tabpanel"]').attr('hidden', true);			

			$(this).closest('.vf-tab-bar-container').find('#' + $(this).attr('aria-controls')).attr('hidden', false);

		}

	});

})(jQuery);

/***/ }),
/* 6 */
/***/ (function(module, exports) {

(function($){

	function updateArrayOffset(el, percentage){

		el.style.strokeDasharray = (percentage * 2.3876) + ',238.76';

	}

	var preloaders = document.getElementsByClassName("vf-preloader");

	for (var i = 0; i < preloaders.length; i++) {

		//Create initial svg with path and text.
		var vfSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
		vfSvg.setAttributeNS(null,"class","vf-preloader-svg");

		var vfSvgPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
		var vfSvgPathElement = vfSvg.appendChild(vfSvgPath);
		vfSvgPathElement.setAttributeNS(null,"class","vf-preloader-circle");
		vfSvgPathElement.setAttributeNS(null,"d","M40 2 a 38 38 0 0 1 0 76 a 38 38 0 0 1 0 -76");

		var vfSvgText = document.createElementNS("http://www.w3.org/2000/svg", "text");
		var vfSvgTextElement = vfSvg.appendChild(vfSvgText);
		vfSvgTextElement.setAttributeNS(null,"class","vf-preloader-percentage");
		vfSvgTextElement.setAttributeNS(null,"x","50%");
		vfSvgTextElement.setAttributeNS(null,"y","50%");
		
		preloaders[i].appendChild(vfSvg);

		//Get percentage and display it. If not available, set to 0.
		var displayPercentage = preloaders[i].getAttribute('data-vf-preloader-percentage');
		if(!displayPercentage){
			displayPercentage = 0;
		}

		preloaders[i].getElementsByTagName('svg')[0].getElementsByTagName('text')[0].textContent = displayPercentage + "%";
		updateArrayOffset(preloaders[i].getElementsByClassName('vf-preloader-circle')[0], displayPercentage);

		var config = { attributes: true};

		// Callback function to execute when mutations are observed
		var callback = function(mutationsList, observer) {

			for(var j = 0; j < mutationsList.length; j++){

		        if (mutationsList[j].type == 'attributes') {

		            if(mutationsList[j].attributeName == "data-vf-preloader-percentage"){         	

		            	mutationsList[j].target.getElementsByTagName('svg')[0].getElementsByTagName('text')[0].textContent= mutationsList[j].target.getAttribute('data-vf-preloader-percentage') + '%';
			            updateArrayOffset(mutationsList[j].target.getElementsByClassName('vf-preloader-circle')[0], mutationsList[j].target.getAttribute('data-vf-preloader-percentage'));

		            }
		        }
		    }
		};

		// Create an observer instance linked to the callback function
		var observer = new MutationObserver(callback);

		// Start observing the target node for configured mutations
		observer.observe(preloaders[i], config);

	}

})(jQuery);

/***/ }),
/* 7 */
/***/ (function(module, exports) {

(function($){

	$('[data-tooltip]').each(function(){

		let tooltip = $(this).data('tooltip');

		if($(this).is('input')){
			//Pseudo-elements are not allowed on input elements.
			$('<div class="vf-tooltip-message">' + tooltip + '</div>').insertAfter(this);
			$('<div class="vf-input-tooltip-icon vf-icon-question"></div>').insertAfter(this);

		}

		else{

			$(this).append('<div class="vf-tooltip-message">' + tooltip + '</div>');

		}

	});

})(jQuery);

/***/ }),
/* 8 */
/***/ (function(module, exports) {

(function($){

	$('.vf-notification-module-icon').unbind().on('click keyup',function(e){
        $(this).siblings('.vf-notification-module').toggleClass('vf-notification-module--show');

        $(this).siblings('.vf-notification-module').attr('aria-expanded', function(index, attr){
		    return attr == "true" ? false : "true";
		});

        e.stopPropagation();
    });

    $(document).click(function(e) {
        if (!$(e.target).is('.vf-notification-module *')) {
            $(".vf-notification-module").removeClass('vf-notification-module--show').attr("aria-expanded","false");
        }
    });

})(jQuery);

/***/ })
/******/ ]);
//# sourceMappingURL=horizon.min.js.map